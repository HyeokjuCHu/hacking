# 📚 Encoding & Endian 정리

## 1. 엔디안 (Endian)

### 🔸 Big Endian
- 큰 바이트를 먼저 저장
- 예: 0x12345678 → [0x12][0x34][0x56][0x78]

### 🔸 Little Endian
- 작은 바이트를 먼저 저장
- 예: 0x12345678 → [0x78][0x56][0x34][0x12]

### ✅ 체크포인트
- Intel CPU: Little Endian
- Network: Big Endian

------

# 📘 인코딩(Encoding)과 디코딩(Decoding)

## 🧾 인코딩이란?

- 인코딩은 데이터를 **특정한 형식으로 변환**하는 것.
- 목적: 데이터 크기 줄이기, 컴퓨터가 이해할 수 있는 형태로 만들기.
- 변환된 데이터를 다시 원래대로 복구하는 것을 **디코딩(Decoding)** 이라고 함.

### 🔒 인코딩 vs 암호화
- **암호화**는 일부러 알아볼 수 없게 변환해 보안을 위한 것이고,
- **인코딩**은 누구나 표준을 따르면 디코딩 가능함.  
  즉, 목적과 접근성이 다름.

### 📌 인코딩의 중요성
- 웹, 시스템, 네트워크 등 **모든 IT 분야에서 중요**.
- 데이터를 효율적으로 저장하고 전송하기 위해 필수.
- 디코딩을 통해 원문을 알아야 하는 경우도 많아서, 자주 쓰이는 인코딩 방식과 형태를 익혀두는 게 좋음.

---

# 🔤 아스키 코드(ASCII)

## 📎 개념
- 컴퓨터는 0과 1만으로 정보를 처리함.
- 우리가 쓰는 문자들을 0과 1로 바꾸려면 숫자 코드로 변환이 필요함 → **아스키 코드가 그 역할**을 함.

## 💡 ASCII란?
- **American Standard Code for Information Interchange**
- 문자를 숫자로 변환하는 문자 인코딩 방식.
- 서로 다른 시스템 간 문자 전송을 쉽게 해줌.

## 🧠 특징
- **1바이트(8비트)** 중 **7비트** 사용 → 총 128개(0~127)의 문자 표현 가능.
- 나머지 1비트는 에러 체크 등 제어용으로 사용됨.
- 아스키 코드에서 각 문자는 고유한 **숫자 값(아스키 값)**을 가짐.
- 예: 문자 `A`는 65, `a`는 97 등

## 📌 활용 예시
- 텍스트 파일, 통신 프로토콜, C언어 문자 처리 등에 널리 사용됨.

---

# 🌐 유니코드(Unicode)

## 📎 배경

- 아스키(ASCII) 코드는 미국 기준으로 만들어져, **영문 알파벳, 숫자, 특수 문자**만 표현 가능했음.
- 하지만 **세계 각국의 다양한 언어**를 표현하기엔 한계가 있었고, 이를 해결하기 위해 **유니코드**가 등장함.

## 🧾 유니코드란?

- **전 세계 모든 언어의 문자**에 고유한 숫자(코드 포인트)를 부여하는 **국제 문자 표준**.
- 유니코드의 **앞 128개 문자**는 아스키와 동일하게 설계되어 **호환성**도 보장됨.
- 유니코드는 U+XXXX 형식으로 표현되며, 이 때 XXXX는 16진수 값임.
  - 예: `U+0041` → 문자 'A'

## 💡 특징

- 최대 32비트까지 확장 가능 → **약 143,000개 이상의 문자**를 표현 가능
- 각 문자마다 고유한 번호를 부여해서, 어떤 언어든 중복 없이 통합 가능

## 🧩 유니코드 인코딩 방식 (UTF 시리즈)

| 인코딩 방식 | 설명 |
|-------------|------|
| **UTF-8**  | 가변 길이(1~4 바이트)로 문자 표현. 가장 널리 사용됨. 아스키와 호환됨 |
| **UTF-16** | 2~4 바이트로 표현. 동아시아 언어에 유리한 경우가 있음 |
| **UTF-32** | 고정 길이 4 바이트. 속도는 빠르지만 공간 비효율적 |

- **UTF** 뒤의 숫자는 **비트 수**를 의미함.
- 어떤 UTF 인코딩을 쓸지는 **시스템 또는 파일의 규약에 따라** 결정됨.

## ✅ 요약

- 유니코드는 **문자 범용성을 해결하기 위한 국제 표준**
- 아스키를 포함하면서도 모든 언어 문자 표현 가능
- **UTF-8**이 가장 널리 쓰이며, 현재 대부분의 웹과 운영체제는 UTF-8을 기본 인코딩으로 사용

---

# 🌐 URL 인코딩 (퍼센트 인코딩)

## 📎 개념
- URL은 제한된 문자만 사용할 수 있음: **알파벳, 숫자, 일부 특수문자**만 허용됨.
- 나머지 문자는 전송 중 깨지거나 오해될 수 있기 때문에 **URL 인코딩** 필요.

## 🔐 특징
- 허용되지 않는 문자 예시: `:/?#[]@!$&'()*+,;= 공백`
- 이런 문자들은 `%` 기호와 함께 **아스키 코드의 16진수**로 변환됨.

예: Welcome, Dreamhack Beginners! :) ↓ Welcome%2C%20Dreamhack%20Beginners%21%20%3A%29


- `%20` → 공백(Space)
- `%21` → `!`
- `%3A` → `:`
- `%29` → `)`

## 📌 요약
- URL 인코딩은 안전하게 데이터를 전송하기 위한 방식
- `% + HEX` 형식으로 문자 인코딩
---

# 🔢 Base64 인코딩

## 📎 개념
- **이진 데이터를 아스키 문자열로 변환**하는 인코딩 방식
- 총 **64개의 문자**(`A–Z`, `a–z`, `0–9`, `+`, `/`)를 사용

## 💡 활용 예시
- 바이너리 데이터를 텍스트 환경에 포함시키기 (예: 이메일, HTML 내 이미지 등)

## 🧠 동작 원리

1. 이진 데이터를 비트 단위로 → 6비트씩 나눔
2. 각 6비트를 **10진수 → Base64 문자 테이블**에서 대응되는 문자로 치환
3. 바이트 수가 3의 배수가 안 맞으면, 마지막에 **`=` 기호 패딩** 추가

## 🧩 예시와 패딩 설명

- 예: 문자열 `ZA`
  - `Z` = `01011010`, `A` = `01000001`
  - 16비트를 6비트씩 나누면 `010110 100100 000100`
  - 앞에서부터 읽다가 마지막 4비트 부족 → `=` 패딩으로 보완

## ✅ 요약

| 특징 | 설명 |
|------|------|
| 사용 문자 | A~Z, a~z, 0~9, +, / (총 64개) |
| 목적 | 바이너리 데이터를 텍스트로 안전하게 전송 |
| 패딩 | `=` 기호로 부족한 비트를 보충 |

