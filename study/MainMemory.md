# Main Memory Summary

## 📌 Background

- 프로그램은 실행 전에 디스크에서 메인 메모리(RAM)로 로드되어야 한다.
- CPU가 직접 접근할 수 있는 저장장치는 **메인 메모리와 레지스터**뿐이다.
- 메모리 유닛은 단순히 **주소와 요청(read/write)**만 처리한다.
- 레지스터 접근은 한 클럭 이내로 매우 빠르지만, 메인 메모리는 느려서 **CPU가 대기(stall)**하는 경우가 생긴다.
- 이 속도 차이를 줄이기 위해 **캐시 메모리(Cache)**가 사용된다.
- 올바른 동작을 위해 **메모리 보호**가 필요하다.

---

## 🛡️ Basic Hardware (메모리 보호)

- 각 프로세스는 **독립된 메모리 공간**을 갖는다.
- 이를 위해 **Base Register**와 **Limit Register**를 사용하여 접근 범위를 제한한다.
- CPU는 메모리 접근 시 **주소가 base 이상이고 base + limit 미만**인지 항상 검사한다.
- 조건을 만족하지 않으면 **운영체제에 트랩(trap)**되어 오류 처리한다.
- Base/Limit 레지스터는 **운영체제만 수정 가능(특권 명령)**하다.

---

## 🧭 Logical vs. Physical Address

- **Logical Address (논리 주소)**: CPU가 생성하는 주소, 사용자 프로그램이 보는 주소.
- **Physical Address (물리 주소)**: 실제 메모리 주소, 메모리 유닛이 보는 주소.
- **MMU (Memory Management Unit)**: 실행 중에 논리 주소를 물리 주소로 변환하는 하드웨어.

---

## 🧮 Address Mapping using Relocation Register

- 간단한 주소 변환 방식으로 **Relocation Register (Base Register)** 사용.
- 논리 주소에 relocation 값을 더해 물리 주소로 변환:
  - `physical = logical + base`
- 사용자 프로그램은 **논리 주소만 알고**, 실제 물리 주소는 보지 못함.

---

## 🧠 Why CPU doesn’t add base directly?

- **유연성**: 여러 프로세스마다 base 값이 달라지므로 MMU가 동적으로 처리하는 게 효율적.
- **보안**: 사용자 프로그램이 물리 주소를 알지 못하게 보호.
- **추상화**: 프로세스는 항상 자기 주소 공간만 다루도록 설계됨.
- **이식성**: 어디에 로딩되든 코드 수정 없이 실행 가능.

---

## 🧩 Dynamic Loading

- 프로그램 전체를 한꺼번에 메모리에 올리면 **물리 메모리 크기 제한**이 문제됨.
- **동적 로딩(Dynamic Loading)**은 **필요한 루틴만 실행 중에 로딩**한다.
  - 루틴이 호출되기 전까지 메모리에 없음
  - 호출 시 로딩, 주소 테이블 갱신, 실행
- **장점**:
  - 사용하지 않는 루틴은 메모리에 올라오지 않음 → 메모리 효율적 사용
  - 운영체제의 특별한 지원 없이도 가능 (다만, 라이브러리 제공 등으로 보완 가능)

---

## 🔗 Dynamic Linking

- **Static Linking**: 컴파일 시 라이브러리 코드를 실행 파일에 포함.
- **Dynamic Linking**: **실행 중에** 필요한 라이브러리를 연결.
  - 라이브러리를 가리키는 작은 코드 조각인 **stub**이 먼저 존재.
  - 처음 호출 시 stub이 라이브러리를 메모리에 로드하고 주소를 찾음.
  - 그 다음부터는 stub이 **자기 자신을 진짜 함수 주소로 바꿈** (재배치).
- **장점**:
  - 라이브러리를 **여러 프로세스가 공유**
  - **업데이트가 쉬움** (라이브러리만 바꾸면 됨)
- **운영체제의 지원 필요** (동적 링커 등)

---

## 📚 Dynamic Loading vs Dynamic Linking

| 구분             | Dynamic Loading                        | Dynamic Linking                         |
|------------------|----------------------------------------|-----------------------------------------|
| 대상             | 루틴 또는 코드 전체                    | 주로 라이브러리 함수                    |
| 로딩 시점        | 호출될 때 코드 로딩                    | 호출될 때 링크 진행                    |
| 주소 갱신 방식   | 주소 테이블을 갱신                     | stub이 실제 함수 주소로 교체           |
| 목적             | 메모리 절약                            | 라이브러리 공유, 유지보수 편의성       |

---

## ✅ 요약

> 메인 메모리는 CPU와 프로그램 간의 핵심 연결고리다.  
> 논리 주소와 물리 주소의 분리, 보호 기법(Base/Limit),  
> 그리고 실행 시 필요한 것만 불러오는 **동적 로딩/링킹** 덕분에  
> 컴퓨터는 효율적이고 안전하게 여러 프로그램을 실행할 수 있다.

